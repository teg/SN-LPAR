% Preempt some bad decisions by LLNCS
\RequirePackage{fixllncs}


\documentclass[orivec]{llncs}



% To get cases in equations
\usepackage{amsmath}


\expandafter\let\csname proof\endcsname\relax
\expandafter\let\csname endproof\endcsname\relax

% To use definitions, lemmas and theorems.
\usepackage{amsthm}

% twoheadleftarrow
\usepackage{amssymb}

% Nicer array and tabular layout (IEEE-suggested)
\usepackage{array}

% A more pleasant font
\usepackage[T1]{fontenc} % use postscript type 1 fonts
\usepackage{textcomp} % use symbols in TS1 encoding
%\usepackage[garamond]{mathdesign} % use a nice font

% A taste of french
%\usepackage[french]{babel}
\usepackage[utf8]{inputenc}

% Allow inclusion of graphics
%\usepackage[pdftex]{graphicx}

% To get url's
%\usepackage[hidelinks]{hyperref}

% Improves the text layout
\usepackage{microtype}

% For in-line lists
\usepackage{paralist}

% To typeset derivations
\usepackage[lutzsyntax,pdftex]{virginialake}

% Landscape-orientated floats
\usepackage{rotating}

% To get semantic brackets
\usepackage{stmaryrd}

% For fancy underlining and strikethroughs
\usepackage[normalem]{ulem}

% Nice fractions
\usepackage{units}

% For commands with multiple optional arguments
\usepackage{xargs}

% Our own stuff
\usepackage{ALmacros}
%\usepackage{includeFigure}
%\input{ALpictures}
\usepackage{willemtools}

% Get counters and fonts right for theorem environments
\spnewtheorem{ALtheorem}{Theorem}{\bfseries}{\itshape}
\spnewtheorem{ALdefinition}[ALtheorem]{Definition}{\bfseries}{\upshape}
\spnewtheorem{ALproposition}[ALtheorem]{Proposition}{\bfseries}{\itshape}
\spnewtheorem{ALlemma}[ALtheorem]{Lemma}{\bfseries}{\itshape}


\newif\ifnonotes\nonotesfalse
\newcommand{\EMPTY}[1]{\ifnonotes\else{\color{red}    \noindent #1}\fi}
\newcommand{\Comment}[1]{\ifnonotes\else{\color{red}    \noindent{\bf Comment: }#1}\fi}
\newcommand{\Remark}[1]{\ifnonotes\else{\color{red}    \noindent{\bf Remark: }#1}\fi}
\newcommand{\TODO}[1]{\ifnonotes\else{\color{red}    \noindent{\bf TODO }#1}\fi}
%\newcommand{\Rem}[1]{\ifnonotes\else{\color{red}    \bigskip\\{\bf Remark: }#1 \bigskip\\}\fi}
%\nonotestrue % If this is commented, notes appear in the paper (if any)
%---------------------------------------------------------- REMOVE WHEN FINISHED




%-------------------------- FRONTMATTER

\title{A Proof of Strong Normalisation of the Typed Atomic Lambda-Calculus}

\author{Tom Gundersen\inst{1} \and
Willem Heijltjes\inst{2} \and
Michel Parigot\inst{1}}

\authorrunning{Gundersen, Heijltjes, \& Parigot}

\institute{Laboratoire Preuves, Programmes, Syst√®mes \\ CNRS \& Universit\'e Paris Diderot \\ {\tt teg@jklm.no, parigot@pps.univ-paris-diderot.fr}
\and University of Bath \\ {\tt w.b.heijltjes@bath.ac.uk} }


% ==============================================================================================================================================================================


\begin{document}


\maketitle


\begin{abstract}
The atomic lambda-calculus is a typed lambda-calculus with explicit sharing, which originates in a Curry-Howard interpretation of a deep-inference system for intuitionistic logic.
%
It has been shown that it allows fully lazy sharing to be reproduced in a typed setting.
%
In this paper we prove strong normalization of the typed atomic lambda-calculus using Tait's reducibility method.
%
\end{abstract}






% =================================================================================================
\section{Introduction}



The \emph{atomic lambda-calculus} is a typeable lambda-calculus with explicit sharing, recently introduced in \cite{Gundersen-Heijltjes-Parigot-2013-JFLA,Gundersen-Heijltjes-Parigot-2013-LICS}, developed as the Curry--Howard interpretation of a deep-inference proof system for intuitionistic logic.
%
The present paper constitutes an important step in the development of its meta-theory, by extending Tait's reducibility method to show strong normalisation of the simply typed atomic lambda-calculus.
%
The primary motivation for establishing this result is to demonstrate that the atomic lambda-calculus is a natural and well-behaved calculus, to which the main standard techniques and results apply.



\emph{Sharing} is an approach to efficient computation in lambda-calculi whereby duplication of subterms is deferred in favor of reference to a common representation.
%
It is a leading principle behind, among others, explicit substitution calculi \cite{Abadi-Cardelli-Curien-Levy-1991,Lescanne-1994,David-Guillaume-2001,DiCosmo-Kesner-Polonovski-2003,Kesner-Lengrand-2007,Accattoli-Kesner-2010}, term calculi with strategies or higher-order transformations \cite{Hughes-1982,Ariola-Felleisen-Maraist-Odersky-Wadler-1995}, and sharing graphs in the style of Lamping \cite{Lamping-1990,Asperti-Guerrini-1998,VanOostrom-VanDeLooij-Zwitserlood-2004}.
%
The atomic lambda-calculus represents a novel category in this range.
%
As a typeable term calculus it is an alternative to explicit substitution calculi, providing a different perspective on sharing: as in sharing graphs, sharing is evaluated \emph{atomically}, by duplicating individual constructors.
%
A salient property is that the calculus implements \emph{fully lazy sharing} \cite{Wadsworth-1971,Hughes-1982,Balabonski-2012}, a degree of sharing that, while standard, had previously been achieved in lambda-calculi only by means of external transformations.



The paper \cite{Gundersen-Heijltjes-Parigot-2013-LICS} details how the atomic lambda-calculus and its sharing mechanisms are derived from \emph{deep inference} \cite{Brunnler-Tiu-2001}, a proof methodology where inferences apply \emph{in context}, reminiscent of term rewriting.
%
Sharing in deep inference is by explicit \emph{contraction} rules, which implement atomic duplication by interacting with individual inferences.
%
By embedding natural deduction within the deep-inference formalism \emph{open deduction} \cite{Guglielmi-Gundersen-Parigot-2010}, duplication in traditional normalisation is broken up into atomic steps.
%
The atomic lambda-calculus is a direct computational interpretation of the resulting proof system.
%
The paper \cite{Gundersen-Heijltjes-Parigot-2013-LICS} further establishes the technical properties of full laziness and \emph{PSN}, preservation of strong normalisation with respect to the lambda-calculus.



In the present paper strong normalisation for the typed atomic lambda-calculus will be proven using the Tait-reducibility method \cite{Tait-1967,ProofsAndTypes}.
%
Reducibility is an abstract method compatible with higher-order logic, whose application provides a deeper understanding of reduction and its dynamics.
%
The fact that a reducibility proof can be carried out for the atomic lambda-calculus shows the generic character of this extension
of the lambda-calculus.
%
Nevertheless, the proof is not a straightforward generalisation of the one for lambda-calculus, because one has to overcome
the lack of local confluence.
%
%I would like to add something like this to avoid that the referee says: it is only a technical
%generalization; you need only perseverance to get it; etc.
%
%For compactness the proof will be carried out for a discipline of simple types, and will be shown extensible to intersection types.



%The characterisation of exactly the strongly normalisable atomic lambda-terms by intersection types is more subtle than for the lambda-calculus, due to the fact that garbage collection is an integral part of the computation.
%
%Such a type system is given in Section~\ref{sec:SND}, and the proof of the characterization is outlined.

%The interaction of atomic duplication rules with beta-reduction means that a certain, natural amount of garbage collection is required inbetween beta-reduction steps.
%
%As a consequence, terms are strongly normalisable that don't appear so.
%
%A characterisation to capture these terms is outlined in the last section of the paper.


% =================================================================================================
\section{The atomic lambda-calculus}
\label{sec:atomic-lambda-calculus}



The \emph{atomic lambda-calculus} introduced in \cite{Gundersen-Heijltjes-Parigot-2013-LICS} is a refined lambda-calculus, in which abstraction is split into a linear abstraction and a sharing operation.
%
Duplication and deletion proceeds locally through the evaluation of sharings.
%
The calculus consists of a standard linear lambda-calculus with a sharing construct, extended by a further construction called the \emph{distributor}.
%
The distributor allows to duplicate an abstraction without duplicating its scope: it replaces the abstraction while duplication of its scope is in progress, where the duplicated parts of the scope are stored in a tuple of terms (see also the reduction rules in Section~\ref{ssec:reduction rules}).



\begin{ALdefinition}
%
The \emph{atomic lambda-calculus} $\Lambda_A$ is defined by the grammars
%
\setMidspace{10pt}
\[
\begin{array}{r@{\Coloneq}c@{\Mid}l}
	s,t,u,v,w
	&	x \Mid \lambda x.t
	&	(t)u \Mid t\g
\\[5pt]
	\g,\g*  &  \share xt  &  \distr xy{t^n}
\\[5pt]
	t^n  &  \tup t  &  t^n\g
\end{array}
\]
where
%
\begin{inparaenum}[(i)]
\item $n\geq0$, 
%
\item each variable may occur at most once in a term,
%
\item in $\lambda x.t$, $x$ must be free in $t$ and becomes bound,
%
\item in $\lambda y.t^n$, $y$ must be free in $t^n$ and becomes bound, %and
%
\item in $t\g$ where $\g$ is $\share xu$ or $\distr xy{t^n}$, each $x_i$ must be free in $t$ and becomes bound, and 
%
\item likewise for $t^n\g$.
%
\end{inparaenum}
%
\end{ALdefinition}



Terms $t$ are \emph{atomic lambda-terms}.
%
The \emph{closures} $\g$ are called respectively \emph{sharing} and \emph{distributor}, and a nullary sharing $\share*{}t$ is a \emph{weakening}.
%
Atomic lambda-terms not containing a distributor are \emph{basic} terms.
%
A sequence of closures $\g[1]\ldots\g[n]$ will be denoted $\g[i]_{i\leq n}$ or $\G$.
%
The $t^n$ are \emph{terms of multiplicity $n$} or \emph{$n$-terms}, and are of the form $\tup t\G$.
%
Where possible, terms and $n$-terms will not be distinguished, and both denoted $t,u,v$.
%
A sequence of variables $\vv x$ may be abbreviated $\vv*x$; a sharing is then denoted $\share*{\vv*x}t$.
%
Standard notions are: $\FV(u)$ is the set of free variables of $u$, and $u\sub xt$ denotes the substitution of $t$ for $x$ in $u$.
%
A series of substitutions $\sub{x_1}{t_1}\dotso\sub{x_n}{t_n}$ is abbreviated $\subn{x_i}{t_i}$.



Atomic lambda terms will be considered up to the congruence $(\sim)$ induced by~\eqref{eqn:explicit permutation} below;
note that due to linearity, both terms are only well-defined if both $\g$ and $\g*$ bind only in $t$.
%
\begin{equation}\label{eqn:explicit permutation}
	t\g\g* ~\sim~ t\g*\g
\end{equation}
%
The functions $\tercoden-\,:\,\Lambda\to\Lambda_A$ and $\terden-\,:\,\Lambda_A\to\Lambda$ translate between atomic lambda-terms and standard lambda-terms.
%
The former is defined below.
%
For a formal definition of the function $\tercoden-$ see \cite{Gundersen-Heijltjes-Parigot-2013-LICS}; intuitively, it replaces each abstraction $\lambda x.-$ in a term by $\lambda x.-\share xx$, where $\vv x$ replace the occurrences of $x$, so that $\terden{\tercoden N}=N$ for any lambda-term $N$.


\begin{ALdefinition}
The functions $\den-$ and $\den*-$ interpret atomic lambda-terms and closures respectively as lambda-terms and substitutions.
%
For a sequence of closures $\G=\g\G'$ with $\G'$ non-empty, let $\BR\G=\BR\g\BR{\G'}$. 
%
\[
\begin{array}{r@{{}={}}l}
	\den x = x
\qquad	\den {\lambda x.t} = \lambda x.\den t
\qquad	\den {(t)u} & (\den t)\den u
\qquad	\den {t\g} = \den t\BR\g
	\\[6pt]	\BR{\share xt}				& \subn{x_i}{\den t}
	\\[6pt]	\BR{\distr xy{\tup t\G}}	& \subn{x_i}{\lambda y.\den{t_i}\BR\G}
\end{array}
\]
%
\end{ALdefinition}






% =================================================================================================
\subsection{Reduction rules}
\label{ssec:reduction rules}

Reduction in the atomic lambda-calculus, denoted $\rewrite$, consists of two parts:
\begin{inparaenum}[\upshape(i)]
 \item linear $\beta$-reduction, denoted $\ALbeta$: the usual rule (rule~\ref{eqn:beta-reduction} below) applied linearly;
 \item sharing reductions, denoted $\ALnotbeta$, comprising two kinds of rule: (a) \emph{permutations} taking closures outward (rules~\ref{eqn:sharing above abstraction}--\ref{eqn:sharing above distribution}), and (b) local \emph{transformations} that evaluate closures (rules~\ref{eqn:compound sharings}--\ref{eqn:distributor elimination}).
\end{inparaenum}
%
\bigskip

\noindent
{\bf Linear  $\beta$-reduction:}
%
\begin{equation}\tag{$\beta$}\label{eqn:beta-reduction}
	(\lambda x.u)t ~\ALbeta~ u\sub xt
\end{equation}



\noindent
{\bf Permutations of closures:}
%
\begin{align}\label{eqn:sharing above abstraction}
	\lambda x.t\g & ~\ALnotbeta~ (\lambda x.t)\g
		 & \text{if}~x\in\FV(t) &&&
\\\label{eqn:sharing above application function}
	(u\g)t & ~\ALnotbeta~ ((u)t)\g
\\\label{eqn:sharing above application argument}
	(u)t\g & ~\ALnotbeta~ ((u)t)\g
\\\label{eqn:sharing above sharing}
	u\share x{t\g} & ~\ALnotbeta~ u\share xt\g
\\\label{eqn:sharing above distribution}
	u\distr xy{t^n\g} & ~\ALnotbeta~ u\distr xy{t^n}\g
		& \text{if}~y\in\FV(t^n) &&&
\end{align}



\noindent
{\bf Transformations on closures:}
%
\begin{gather}
\label{eqn:compound sharings}
	u\share*{\vv*y}y\share*{\vv*x,y,\vv*z}t ~\ALnotbeta~
	u\share*{\vv*x,\vv*y,\vv*z}t
\\[5pt]
\label{eqn:share application}
	u\share x{(v)t} ~\ALnotbeta~
	u\subn{x_i}{(y_i)z_i}\share yv\share zt
\\[5pt]
\label{eqn:share abstraction}
	u\share x{\lambda x.t}~\ALnotbeta~ u\distr xx{\tup y\share yt}
\\[5pt]\notag
	u\distr xy{\tup t\share*{\vv*z}{y}}~\ALnotbeta~
	u\subn{x_i}{\lambda y_i.t_i\share*{\vv*z_i}{y_i}}
\\[5pt]
	\rule{4cm}{0pt}\mbox{where } \{\vv*z_i\} = \{\vv*z\}\cap\FV(t_i) \mbox{ for every }i\leq n
\label{eqn:distributor elimination}
\end{gather}


The fact that a term $u$ reduces to $v$ in exactly $n$ steps will be denoted $u \rewrite^n v$, while an arbitrary number of steps is indicated simply by $\rewrite$.
%
A term $u$ is called \emph{strongly normalisable} if all the reduction sequences starting with $u$ are finite.
%
The set of strongly normalisable terms is denoted $\SN$.
%
Reduction in the atomic lambda-calculus commutes 1--1 with substitution, due to the linearity condition on free variables.


\begin{ALlemma}
For atomic lambda-terms $u$, $u'$, $v$ and $v'$ and variable $x \in \FV(u)$,
%
if $u \rewrite^1 u'$, then $u\sub xv \rewrite^1 u'\sub xv$; and
if $v\rewrite^1 v'$, then $u\sub xv \rewrite^1 u\sub x{v'}$.
\end{ALlemma}


% =================================================================================================
\subsection{Basic properties of the atomic lambda-calculus}
\label{ssec:basic properties}

We collect in this section the main basic properties we are using in the strong normalisation proof. The two main properties are (i) the strong normalisation property of the sharing reduction, and (ii) the  decomposition of the computational content of sharings and distributors.

\begin{ALtheorem}[{\cite[Theorem 11]{Gundersen-Heijltjes-Parigot-2013-LICS}}]
\label{thm:sharing SN}
The reduction $\ALnotbeta$ is strongly normalising and confluent.
\end{ALtheorem}

\noindent
%
Sharing reductions preserve the denotation $\den t$ of a term \cite[Prop.~10]{Gundersen-Heijltjes-Parigot-2013-LICS}.
%
The normal form under $\ALnotbeta$ of an atomic lambda-term $t$ is called its \emph{unfolding} $\unfold(t)$.
%
It is a basic term (i.e., no distributors occur) of the form $u\G$, where sharing in $u$ occurs only as $\lambda y.v\share*{\vv*x}y$, of bound variables immediately within the scope of their binder, and where $\G$ are sharings $\share*{\vv*x}y$ of the free variables $y$ in $t$ that occur in shared subterms \cite[Prop.~9]{Gundersen-Heijltjes-Parigot-2013-LICS}.
%
For closed terms, $\unfold(t)=_\alpha\tercoden{\terden t}$.



\begin{ALdefinition}
The \emph{unfolded body} $\sn(t)$ of $t$ is the largest subterm of $\unfold(t)$ not of the form $u\g$.
\end{ALdefinition}
%
%
The unfolded body of a term is what is duplicated during reduction.
%
To identify the various copies, let a \emph{variant} of a term $t$ be any term obtained from $t$ by renaming certain (bound or free) variables.
%
A variant is \emph{fresh} if all its variables are fresh, and $t^i$ is the fresh variant of $t$ obtained by replacing each
variable $x$ by a fresh variable $x^i$.


For an $n$-term $t^n=\tup t\G$ let the \emph{$i^{\mbox{\scriptsize th}}$ projection} $\pi_i(t^n)$ be the atomic lambda term $t_i\G[i]$ where $\G[i]$ is obtained by removing the binders from $\G$ binding in any $t_j$ ($i\neq j$), and iteratively removing binders in $s_k$ when $x_k$ is removed from a distributor $\distr*{x_1,\dotsc,x_k,\dotsc,x_m}y{\tup*{s_1,\dotsc,s_k,\dotsc,s_m}\G'}$.


The following basic facts then characterise $\sn$.


\begin{ALproposition}
\[
\begin{aligned}
	\sn(x) = x \quads3
	\sn(\lambda x.t) & =\lambda x.\sn(t)\share*{\vv*x}x \quads3
	\sn((u)v) = (\sn(u))\sn(v)
\\[5pt]
   \sn(u\share xt) & =\sn(u)\subn{x_i}{\sn(t)^i}
\\[5pt]
	\sn(u\distr xy{t^n}) &=\sn(u)\subn{x_i}{\sn(\lambda y.\pi_i(t^n))^i}
\end{aligned}
\]
\end{ALproposition}


\begin{ALproposition}\label{prop:sn_pi}
For $t=\tup t\G$, $\sn(\pi_i(t))=\sn(t_i\share*{}{x_1}\dots\share*{}{x_m}\G)$ where
$\vv[m]x$ are the free variables of all $t_j$ ($i\neq j$).
\end{ALproposition}



To characterise the effects of duplication on the free variables of a term $t$ or an abstracted $n$-term $\lambda y.t^n$, let $\FV(t)=\FV(\lambda y.t^n)=\{y_1,\dots,y_k\}$, and let $\FV(\sn(t)^i)=\FV(\sn(\lambda y.\pi_i(t^n))^i)=\{\vv*y_1^{\;i},\dotsc,\vv*y_k^{\;i}\}$.
%
Define the \emph{renamings} of $t$ and $\lambda y.t^n$ to be the sharings $\share*{\vv*y_i^{\;1},\dots,\vv*y_i^{\;n}}{y_i}_{i\leq k}$, denoted $[\sh (t):1,\dots,n]$ and $[\sh(\lambda y.t^n):1,\dots,n]$ and abbreviated $[\sh(t)]$ and $[\sh(\lambda y.t^n)]$ where possible.
%
The unfolded body and the renamings give the following key decomposition properties of the computational content of closures.


\begin{ALlemma}
\label{lem:unsharing}
$u\share xt \rewrite u\subn{x_i}{\sn(t)^i}[\sh (t)]$
\end{ALlemma}


\begin{ALlemma}
\label{lem:undist}
$u\distr xy{t^n} \rewrite u\subn{x_i}{\sn(\lambda y.\pi_i(t^n))^i}[\sh (\lambda y.t^n)]$
\end{ALlemma}




% =================================================================================================
\section{Typed atomic lambda-calculus}
\label{sec:types}


The simply typed atomic lambda-calculus $S_a$ is defined by the following rules (see \cite{Gundersen-Heijltjes-Parigot-2013-JFLA,Gundersen-Heijltjes-Parigot-2013-LICS}).
%
Terms, including variables, are typed $t:A$ with $A$ a \emph{minimal} formula, one built over $\vlim$, while $n$-terms are typed by \emph{conjunctive} formulae, $t^n:A_1\vlan\cdots\vlan A_n$.
%
With the notation $t^*$ indicating either a term or an $n$-term, a \emph{judgment} is of the form $x_1:A_1,\dotsc,x_n:A_n\vdash t^*:B$, where $\vv x$ are the free variables of $t^*$. 
%
The antecedent $x_1\colon A_1,\ldots,x_n : A_n$ of a judgement is treated as a set, denoted $\Gamma$, $\Delta$, and abbreviated $(x_i\colon A_i)_{i\leq n}$, or $\vv*x:A$ if $A_i=A$ for all $i$.



\bigskip
\noindent
{\bf Typing rules of $S_a$:}
\[
\begin{array}{@{}c@{}}
	\begin{array}{c@{\quads4}c}
	  \vlinf{}{\typeabs}
	   {\Gamma \vdash \lambda x.t : A \vlim B}
	   {\Gamma, x : A \vdash t : B}
	&
	  \vliiinf{}{\typeapp}
	   {\Gamma, \Delta \vdash (u)v : B}
	   {\Gamma \vdash u : A\vlim B}
	   {}
	   {\Delta \vdash v : A}
	\\ \\
	  \vlinf{}{\typevar}{x:A\vdash x:A}{}
	&
	  \vliiinf{}{\typetuple _n}
	   {\Gamma_1, \dots, \Gamma_n \vdash \langle t_1,\ldots,t_n\rangle : A_1\vlan\cdots\vlan A_n}
	   {\Gamma_1 \vdash t_1 : A_1}
	   {\quad\cdots\quad}
	   {\Gamma_n \vdash t_n : A_n}
	\end{array}
\\ \\[5pt]
  \vliiinf{}{\typeshare}
   {\Gamma, \Delta \vdash t^*\share xu : A}
   {\Gamma, (x_i : B)_{i\leq n} \vdash t^* : A}
   {}
   {\Delta \vdash u : B}
\\ \\[5pt]
  \vliiinf{}{\typedist}
   {\Gamma, \Delta \vdash s^*\distr xy{t^n} : C}
   {\Gamma, (x_i : A \vlim B_i)_{i\leq n} \vdash s^* : C}
   {}
   {\Delta, y : A \vdash t^n : B_1\vlan\cdots\vlan B_n}
\end{array}
\]


The type system $S_a$ of the atomic lambda-calculus is a refinement of the simply typed lambda-calculus $S$: the rules $\typevar$, $\typeabs$, and $\typeapp$ are the rules of $S$ restricted by the linearity condition.
%
The rule for sharing, $\typeshare$, is a standard cut-rule combined with contraction on the left.
%
Similarly, the rule for the distributor, $\typedist$, is a cut-rule, albeit a highly non-standard one.
%
It contracts on $A$, the antecedent of the implications, but not on their consequent, integrating a limited amount of deepness.


The typed atomic lambda-calculus ${S_a}$ enjoys the usual properties of typed systems, in particular subject reduction.


\begin{ALtheorem}[\cite{Gundersen-Heijltjes-Parigot-2013-JFLA}]
If $\Gamma\vdash u : A$ and $u \rewrite v$, then $\Gamma\vdash v : A$.
\end{ALtheorem}

\noindent
Moreover, types are preserved in the interpretation of standard lambda-terms as atomic lambda-terms, by inserting sharing-inferences $(\typeshare)$ where required.

\begin{ALproposition}\label{prop:types preserved}
If $\Gamma\vdash N:A$, then $\Gamma\vdash \tercoden N:A$
\end{ALproposition}


Despite the fact that sharing reductions are strongly normalising, commute with denotation, and preserve typing, preservation of strong normalisation (PSN) is not immediate since infinite reduction may take place within weakenings: consider the denotation $\terden{ x\share*{}t}=x$ where $t$ is not SN.
%


% =================================================================================================
\section{Proof of Strong Normalisation for Simple Types}
\label{sec:SNproof}

In this section we prove the strong normalisation theorem for atomic lambda-terms, typed in the system $S_a$, using Tait's reducibility method. 
%
The proof of the main proposition (Proposition~\ref{prop:IntSubst}) relies on closure properties of the reducibility sets (Lemma~\ref{lem:IntCaseLambdaSharing}), which again relies on closure properties on the set of strongly normalisable atomic lambda terms proved in Section~\ref{sec:ClosPropSN}.


For simplifying the presentation, we consider in the remainder of this paper, that no beta-reduction happens inside $n$-tuples, that $n$-tuples are unfolded, and that all their free variables are captured by closures. This property is preserved by reduction and it is natural in the context of sharing calculus. In particular all the useful computation strategies satisfy it, including the one reproducing fully lazy sharing.


\begin{ALdefinition}
The \emph{value} $|A|$ of a formula $A$ is defined inductively by:
\[
\begin{array}{lll}
|X| & = & \mathcal{N}
\\
%|A\cap B| & = & |A| \cap |B|
%\\
|A\vlim B| & = & \mbox{\{$u$ \;|\;  $u$ is a term and, for each term $v\in |A|$, $(u)v \in |B|$ \}}
\end{array}
\]
Values are extended to conjunctive formulae by the following clauses, for $n>0$.
%
We denote by $\VAR$ the set of variables, and note that $\tup*{}$ is the empty tuple.
%
\[
\begin{array}{lll}
|A_1\vlan\dots\vlan A_n| & = & \mbox{\{$t^n$ \;|\; for each $i\leq n$, $\pi_i(t) \in |A_i|$\}}
\\
|\top| & = & \mbox{\{$\tup*{}\G$ \;|\; for any $x\in\VAR$, $x\G\in\SN$\}}
\end{array}
\]
\end{ALdefinition}
%
%
Values of formulae are called {\em reducibility sets}. 
%
Note that if $t\in|A|$ and $t'$ is a variant of $t$, then $t'\in|A|$.


\begin{ALproposition}\label{prop:IntBase}
For each minimal formula $A$, $\VAR \subseteq |A| \subseteq  \SN$
\end{ALproposition}

\begin{ALproposition}
 For any formulae $A_1,\dots,A_n$, $|A_1\vlan\dots\vlan A_n| \subseteq \SN$.
\end{ALproposition}



\begin{ALlemma}\label{lem:RedStab}
For any formula $A$,  if $u\in |A|$ and $u \rightsquigarrow v$, then $v \in |A|$ .
\end{ALlemma}

\begin{proof}
 Immediate by induction on $A$.
\end{proof}


Let $\cxt\overline w$ denote a term context consisting of repeated applications, so that $\cxt*u\overline w$ is $(\dotso(u)w_1\dotso )w_n$.


\begin{ALlemma}\label{lem:Red-AddSharings}
For any formula $B$,  if $u\in |B|$ then $u\share*{\vv*x}y \in |B|$.
\end{ALlemma}

\begin{proof}
By induction on $B$, if $(u)\overline w\in|B|$ then $(u\share*{\vv*x}y)\overline w\in |B|$.
\end{proof}

\begin{ALlemma}\label{lem:IntCaseLambdaSharing}
~
\begin{compactenum}[\upshape(i)]
%
\item If $u\{v/x\} \in |B|$ and $x\in\FV(u)$, then $(\lambda x.u) v \in |B|$.
\\[-9pt]
\item If $u\subn{x_i}{\sn(t)^i}[\sh (t)] \in |B|$ and $t\in\SN$, then $u[x_1,\dots,x_n \leftarrow t] \in |B|$.
\\[-9pt]
\item If $u\subn{x_i}{\sn(\lambda y.\pi_i(t^n))^i}[\sh (\lambda y.t^n)] \in |B|$ and $t^n\in\SN$, \\
\\[-9pt]	then $u\distr xy{t^n} \in |B|$.
%
\end{compactenum}
%
\end{ALlemma}

\begin{proof}
Each case is proved by induction on $B$, using context $\{\cdot\}\overline w$.

(i) If $B$ is a variable, $|B| = \SN$ and the result is given by Lemma~\ref{lem:IntCaseLambda0}.
%
Otherwise, let $B= C\vlim D$.
%
Suppose $(u\{v/x\})\overline{w} \in |C\vlim D|$ and $x\in\FV(u)$.
%
Let $t\in|C|$. 
%
We prove that  $(((\lambda x.u) v)\overline{w})t \in |D|$.
%
Because $(u\{v/x\})\overline{w} \in |C\vlim D|$ and $t\in|C|$, we have $((u\{v/x\})\overline{w})t \in |D|$ and by the induction hypothesis, $(((\lambda x.u) v)\overline{w})t \in |D|$.
%
It follows that $((\lambda x.u) v)\overline{w} \in |C\vlim D|$.


(ii) If $B$ is a variable, $|B| = \SN$ and the result is given by Lemma~\ref{lem:IntCaseSharing0}.
\\
Otherwise, let $B= C\vlim D$.
%
Let $u'=(u\subn{x_i}{\sn(t)^i}[\sh (t)])\overline{w} \in |C\vlim D|$ and $t\in\SN$.
%
Let $v\in|C|$.
%
We prove that $((u\share xt)\overline{w})v \in |D|$.
%
By the definition of $|C\vlim D|$ we have $(u')v\in|D|$.
%
By the induction hypothesis $((u[x_1,\dots,x_n \leftarrow t])\overline{w})v \in |D|$.
%
It follows that $(u[x_1,\dots,x_n \leftarrow t])\overline{w} \in |C\vlim D|$.
%\\

(iii) The proof is similar to that of (ii).
%
\end{proof}

\begin{ALproposition}\label{prop:IntSubst}
If $(x_i:A_i)_{i\leq n}\vdash u:B$ and $v_i \in |A_i|$, then $u\subn{x_i}{v_i} \in |B|$.

\end{ALproposition}

\begin{proof}
%
We proceed by induction on the derivation of $(x_i:A_i)_{i\leq n}\vdash u:B$.
%
\begin{enumerate}
\setlength{\itemsep}{\medskipamount}%
\setlength{\parskip}{0pt}

	\item
The last rule is $\typevar$, with conclusion $x:A\vdash x:A$.
%
For $v\in|A|$ we have $x\{v/x\} = v\in|A|$.


	\item
The last rule is
\[
  \vliiinf{}{\typeapp}
	{(x_i:C_i)_{i\leq n},(y_j:D_j)_{j\leq m}\vdash (t)u : B}
	{(x_i:C_i)_{i\leq n}\vdash t : A\vlim B}
	{}
	{(y_j:D_j)_{j\leq m}\vdash u : A}
\]
Let $v_i\in|C_i|$ and $w_j\in|D_j|$ for $i\leq n$ and $j\leq m$.
%
By the induction hypothesis, $t\subn{x_i}{v_i}\in|A\vlim B|$ and $u\subn[m][j]{y_j}{w_j}\in|A|$.
%
By the definition of $|-|$,
%
\[
	((t)u)\subn{x_i}{v_i}\subn[m][j]{y_j}{w_j} = (t\subn{x_i}{v_i})u\subn[m][j]{y_j}{w_j} \in|B|\;.
\]


	\item
The last rule is
\[
  \vlinf{}{\typeabs}
	{(x_i:C_i)_{i\leq n} \vdash \lambda x.t : A \vlim B}
	{(x_i:C_i)_{i\leq n}, x : A \vdash t : B}
\]
Let $v_i \in |C_i|$ for $i\leq n$, and suppose $w\in |A|$. 
%
By the induction hypothesis we have $t\subn{x_i}{v_i}\sub xw\in|B|$. 
%
By Lemma~\ref{lem:IntCaseLambdaSharing}, $(\lambda x.t\subn{x_i}{v_i})w \in |B|$.
%
It follows that 
\[
	(\lambda x.t)\subn{x_i}{v_i} = \lambda x.t\subn{x_i}{v_i}\in | A\vlim B|\;.
\]


	\item
The last rule is
\[
  \vliiinf{}{\typeshare}
	{(y_i:C_i)_{i\leq k}, (z_i:D_i)_{i\leq m} \vdash u\share xt : A}
	{(y_i:C_i)_{i\leq k}, (x_i:B)_{i\leq n} \vdash u : A}
	{}
	{(z_i:D_i)_{i\leq m} \vdash t : B}
\]
Let $v_i\in|C_i|$ and $w_j\in|D_j|$ for $i\leq k$ and $j\leq m$, and let $u'= u\subn[k]{y_i}{v_i}$ and $t'=t\subn[m][j]{z_j}{w_j}$.
% 
We have to prove that the following term is in $|A|$:
\[
	(u\share xt)\subn[k]{y_i}{v_i}\subn[m][j]{z_j}{w_j}= u'\share x{t'}\;.
\]
By the induction hypothesis, $t'\in|B|$; then by Lemma~\ref{lem:RedStab} also the unfolded body $\sn(t')$ is in $|B|$.
%
Let $\sn(t')^1,\dotsc,\sn (t')^n$ be fresh variants.
%
By the induction hypothesis,
$
	u'\subn{x_i}{\sn(t')^i}\in|A|
$,
and $u'\subn{x_i}{\sn(t')^i}[\sh(t')]\in|A|$ by Lemma~\ref{lem:Red-AddSharings}.
%
It follows by Lemma~\ref{lem:IntCaseLambdaSharing} that $u'\share x{t'}\in |A|$.


	\item
The last rule is
\[
\hspace{-\leftmargin}
  \vliiinf{}{\typedist}
	{(y_i:C_i)_{i\leq k}, (z_i:D_i)_{i\leq m} \vdash u\distr xy{t^n} : C}
	{(y_i:C_i)_{i\leq k}, (x_i:A \vlim B)_{i\leq n} \vdash u : C}
	{\hspace{-6pt}}
	{(z_i:D_i)_{i\leq m}, y : A \vdash t^n : B\vlan\cdots\vlan B}
\]
Let $v_i\in|C_i|$ and $w_j\in|D_j|$ for $i\leq k$ and $j\leq m$, and let $u'=u\subn[k]{y_i}{v_i}$ and $t'=t^n\subn[m][j]{z_j}{w_j}$.
%
We have to prove that the following term is in $|C|$:
\[
	(u\distr xy{t^n})\subn[k]{y_i}{v_i}\subn[m][j]{z_j}{w_j}=u'\distr xy{t'}\;.
\]
%
By the induction hypothesis,
$
	t'\sub ys \in|B\vlan\cdots\vlan B|
$
for each $s\in |A|$,
%
and therefore $\pi_i(t'\sub ys)=\pi_i(t')\sub ys\in|B|$.
%
Then, for each $s\in |A|$, $(\lambda y.\pi_i(t'))s \in|B|$ by Lemma~\ref{lem:IntCaseLambdaSharing}, and by definition of $|-|$, $\lambda y.\pi_i(t')\in|A\vlim B|$.
%
By Lemma~\ref{lem:RedStab} also the unfolding of $\lambda y.\pi_i(t')$ belongs to $|A \vlim B|$, as does any variant $\sn(\lambda y.\pi_i(t'))^i$.
%
By the induction hypothesis, $u'\subn{x_i}{\sn(\lambda y.\pi_i(t'))^i}$ is in $|C|$, and by Lemma~\ref{lem:Red-AddSharings},
$
	u'\subn{x_i}{\sn(\lambda y.\pi_i(t'))^i}[\sh(\lambda y.t^n)]\in|C|.
$
%
It follows by Lemma~\ref{lem:IntCaseLambdaSharing} that $u'\distr xy{t'}\in|C|$.
%
\end{enumerate}
%
\end{proof}



\begin{ALtheorem}\label{thm:SN}
If $(x_i:A_i)_{i\leq n} \vdash u:B$ then $u \in \SN$.
\end{ALtheorem}



\begin{proof}
%
Suppose $(x_i:A_i)_{i\leq n} \vdash u:B$.
%
By Proposition~\ref{prop:IntBase}, we have $x_i\in |A_i|$ for $i\leq n$.
%
Therefore by Proposition~\ref{prop:IntSubst},  $u\subn{x_i}{x_i}\in |B|$, i.e.\ $u \in |B|$, and by Proposition~\ref{prop:IntBase} we have $u \in \SN$.
%
\end{proof}


% =================================================================================================
\section{Closure properties of Strongly Normalisable Atomic Lambda Terms}
\label{sec:ClosPropSN}

\newcommand\R{\mathcal R}
\renewcommand\S{\mathcal S}


In this section we prove closure properties for the set of strongly normalisable atomic lambda terms
which are used in Section~\ref{sec:SNproof}.
%
To strengthen the induction hypothesis in several lemmata, we define a further context, $\cxt\overline {w\D}$, which is given by the following grammar.
%
\setMidspace{10pt}
\[
	* \Coloneq  \cxt \Mid (*)u \Mid *\g*
\]
%
The terms within a context $\cxt\overline{w\D}$ are denoted $\overline w=w_1,\ldots,w_n$, and the sharings are denoted $\overline{\D}=\g*[1],\dotso,\g*[m]$.


\begin{ALlemma}\label{lem:HeadVar}
If $x\in \VAR$ and in $\cxt\overline w$ each $w_i\in\SN$, then
$(x)\overline{w} \in \SN$.
\end{ALlemma}
%

For each term $t\in\SN$, we denote by $\R(t)$ the sum of the number of reduction steps in all reduction sequences of $t$ to its normal form.
%
For any term $t$, we denote by $\S(t)$ the number of sharing-reduction steps in all reduction paths to $\unfold(t)$.

%
\begin{ALlemma}\label{lem:IntCaseLambda0}
If $(u\sub xv)\overline w \in \SN$ and $x\in\FV(u)$, then $((\lambda x.u)v)\overline w \in \SN$.
\end{ALlemma}

\begin{proof}
To obtain a suitable induction hypothesis, the context $\cxt\overline w$ is strengthened to $\cxt\overline{w\D}$, and further closures are inserted.
%
It will be shown by induction on $(\R(T'),\S(T))$ that if $T'\in\SN$ then $T\in\SN$, where
\[
	T = (((\lambda x.u)\G) v)\overline{w\D} \qquad T' = (u\sub xv\G)\overline{w\D}\;.
\]
%
It will be shown that for any term $U$ reached by a reduction step $T\rewrite^1 U$, there is a term $U'$ reached by a reduction $T'\rewrite U'$, such that the induction hypothesis applies to $U$ and $U'$ and $(\R(U'), \S(U))<(\R(T'),\S(T))$, giving $U\in\SN$.
%
Since this holds for any term $U$, it follows that $T\in\SN$.


The first, special case, is $T'=U$ (with $\G$ empty), for which $U\in\SN$ is immediate. For the remaining cases, we have to verify that $U$ and $U'$ have the right form, that the measure decreases and that $T'\rewrite U'$, which implies that $U'\in\SN$.
%
In the following cases, $\R(U')<\R(T')$.


\begin{enumerate}

	\item % 2)
If $T\rewrite^1 U$ is due to $u\rewrite^1 u'$, then $U$ and $U'$ are as follows.
\[
	U = (((\lambda x.u')\G) v)\overline{w\D}
\qquad
	U'= (u'\sub xv\G)\overline{w\D}
\]

	\item % 8
If $T\rewrite^1 U$ is due to $v\rewrite^1 v'$, then $U$ and $U'$ are as follows.
\[
	U = (((\lambda x.u)\G) v')\overline{w\D}
\qquad
	U'= (u\sub x{v'}\G)\overline{w\D}
\]

	\item % 4
If $T\rewrite^1 U$ is due to a rewrite step entirely inside $\G$ or inside $\overline{w\D}$---which covers any rule except \eqref{eqn:share application} and \eqref{eqn:distributor elimination}---then $U$ and $U'$ are as follows.
\[
	U = (((\lambda x.u)\G') v)\overline{w'\D'}
\qquad
 	U'= (u\sub xv\G')\overline{w'\D'}
\]

	\item % 5
If $T\rewrite^1 U$ is due to an application of rule \eqref{eqn:share application} or \eqref{eqn:distributor elimination} to $\G$ with subsitutions in $u$, then $U$ and $U'$ are as follows.
 \[
 	U = (((\lambda x.u')\G') v)\overline{w\D}
\qquad
	U'= (u'\sub xv\G')\overline{w\D}
\]

	\item % 5b
If $T\rewrite^1 U$ is due to an application of rule \eqref{eqn:share application} or \eqref{eqn:distributor elimination} to $\overline{w\D}$ with subsitutions anywhere in $((\lambda x.u)\G)v$, then $U$ and $U'$ are as follows.
 \[
 	U = (((\lambda x.u')\G') v')\overline{w'\D'}
\qquad
	U'= (u'\sub x{v'}\G')\overline{w'\D'}
\]

\end{enumerate}


\noindent
For the remaining cases, $\R(U')\leq\R(T')$ and $\S(U) < \S(T)$.

\begin{enumerate}
\setcounter{enumi}{5}
	\item % 3)
If $T\rewrite^1 U$ is an application of permutation rule \eqref{eqn:sharing above abstraction} to $\g$ in $\lambda x.u'\g$, where $u=u'\g$, then $U$ and $U'$ are as follows (note that $T'=U'$).	
\[
	U = (((\lambda x.u')\g\G) v)\overline{w\D}
\qquad
	U'= (u'\sub xv\g\G)\overline{w\D}
\]

	\item % 6)
If $T\rewrite^1 U$ is an application of permutation rule \eqref{eqn:sharing above application function} to $\g$ in $((\lambda x.u)\G'\g)v$, where $\G=\G'\g$, then $U$ and $U'$ are as follows (note that $T'=U'$).
\[
	U = ((((\lambda x.u)\G') v)\g)\overline{w\D}
\qquad	
	U'= (u\sub xv\G'\g)\overline{w\D}
\]

	\item % 7)
If $T\rewrite^1 U$ is an application of permutation rule \eqref{eqn:sharing above application argument} to $\g$ in $((\lambda x.u)\G)v'\g$, where $v=v'\g$, then $U$ and $U'$ are as below.
%
Note that $T'\rewrite U'$ by permuting $\g$ outward, from $u\sub x{v'\g}$ to $u\sub x{v'}\g$, and $T'=U'$ if $u=x$.
%
\[
	U = ((((\lambda x.u)\G) v')\g)\overline{w\D}
\qquad
	U'= (u\sub x{v'}\G\g)\overline{w\D}
\]
\end{enumerate}
\end{proof}


\newcommand{\term}{\mathsf b} %{\mathsf{t}}}
\newcommand{\comp}{^{\mathsf c}}


For the following proofs, we associate with each closure $\g$ its \emph{body} $\term\g$ and its \emph{computation} $\g\comp$, defined as follows.
%
\begin{align*}
	\term\share*{\vv*x}t 		&= t
 \\	\term\distr*{\vv*x}y{t^n}	&= \lambda y.t^n
 \\	\share xt\comp 				&= \subn{x_i}{\sn(t)^i}[\sh (t)]
 \\	\distr xy{t^n}\comp 		&= \subn{x_i}{\sn(\lambda y.\pi_i(t^n))^i}[\sh (\lambda y.t^n)]
\end{align*}

\begin{ALlemma}\label{lem:CompSubst}
~
\begin{compactenum}
	\item
If $z$ is free in $t$, then $u\share*{\vv*x}t\comp\sub zw \rewrite u\share*{\vv*x}{t\sub zw}\comp$.
	\item
If $z$ is free in $t^n$, then $u\distr*{\vv*x}y{t^n}\comp\sub zw \rewrite u\distr*{\vv*x}y{t\sub zw}\comp$.
\end{compactenum}
\end{ALlemma}

\begin{proof}
Immediate from the definitions, Lemma~\ref{lem:unsharing}, and Lemma~\ref{lem:undist}.
\end{proof}
%

The notation $\g^*$ will indicate a either $\g$ or $\g\comp$.
%
For a sequence of closures $\G = \g[1]\dots\g[p]$, we denote by $\G^*$ a \emph{partial computation} $\g[1]^*\dots\g[p]^*$. 
%
Analogously, $\cxt\overline{w\D^*}$ denotes a partial computation for a context $\cxt\overline{w\D}$.


In order to measure the number of reduction steps in a context $\overline{w\D}$, we use the notion of \emph{applicative $n$-term}, defined by the following grammar.
\[
	T^n \Coloneq \tup t \Mid T^n\g \Mid (T^n)t
\]
Rewrite rules apply to applicative $n$-terms as normal, but reduction within the tuple is permitted.
%
Then for a term $(u)\overline{w\D}$, reduction in the context $\overline{w\D}$ is separated from that in $u$ by considering reduction in the applicative $n$-term $\tup x\overline{w\D}$, where $\{\vv x\}=\FV(u)$.


\begin{ALlemma}\label{lem:compute context}
For any terms $t$, $v$, and $w$, if $t\rewrite^1v$ and $t\ALnotbeta w$ then $w\rewrite \unfold(v)$.
\end{ALlemma}

\begin{proof}
There are two cases.
\begin{compactenum}
\item
If $t\ALnotbeta^1v$, then $\unfold(v)=\unfold(w)$, as sharing reduction is confluent and strongly normalising by Theorem~\ref{thm:sharing SN}.
\item
If $t\ALbeta^1v$, by \cite[Lemma 17 and Theorem 18]{Gundersen-Heijltjes-Parigot-2013-LICS} the unfolding of $w$ beta-reduces (in zero or more beta-steps) to a term $w'$ such that $\unfold(w')=\unfold(v)$.
\end{compactenum}
\end{proof}

\begin{ALlemma}\label{lem:IntCaseSharing0}
  If $(u\g\comp)\overline w \in \SN$ and $\term\g\in\SN$, then $(u\g)\overline w \in \SN$.
\end{ALlemma}

\newcommand\M{\mathcal M}

\begin{proof}
%
The following stronger statement will be proved: given 
\[
	T = (u)\overline{w\D}
\qquad\hbox{and}\qquad
	T'= (u)\overline{w\D^*}\;,
\]
%
let $T^n$ be the applicative $n$-term $\tup x\overline{w\D}$ where $\FV(u)=\{\vv*x\}$.
%
If $T'\in\SN$ and $T^n\in\SN$, then $T\in\SN$.


We proceed by induction on the measure $(\R(T'),\R(T^n))$.
%
For each term $U$ reached by a reduction step $T\rewrite^1U$ it will be shown that $U\in\SN$, proving that $T\in\SN$.
%
This will be done by giving a term $U'$ reachable by a reduction $T'\rewrite U'$, to which the induction hypothesis applies; note that since $T'\in\SN$ also $U'\in\SN$, but it must also be shown that the corresponding $n$-term $U^n$ is in $\SN$.
%
The induction hypothesis for $U$ and $U'$ then gives $U\in\SN$.



\begin{enumerate}
	\item
If the reduction step $T\rewrite^1U$ takes place inside $u$, then $U$ and $U'$ are as follows.
\[
	U = (u')\overline{w\D}
\qquad
	U'= (u')\overline{w\D^*}
\]
Then $\R(U')<\R(T')$, and $U^n=T^n\in\SN$ since $\FV(u)=\FV(u')$.



	\item
If the reduction step $T\rewrite^1U$ takes place inside the context $\overline{w\D}$, then $\R(U^n)<\R(T^n)$.
%
Let $U$ and $U'$ be
%
\[
	U = (u')\overline{w'\D'}
\qquad
	U'= (u')\overline{w'\D'^*}
\]	
%
where every closure in $\overline{w'\D'^*}$ is computed.
%
The reduction $T\rewrite^1 U\ALnotbeta U'$ corresponds 1-1 to a reduction from $T^n=\tup x\overline{w\D}$ of the form
\[
	T^n\rewrite^1 V\ALnotbeta\unfold(V)\;,
\]
%
given that only unfolded terms are instantiated into the $n$-tuple in the reduction $V\ALnotbeta\unfold(V)$, which holds due to the restriction on tuples instated in the beginning of Section~\ref{sec:SNproof}.
%
Similarly, for the reduction $T\ALnotbeta T'$ there is a corresponding $T^n\ALnotbeta W$.
% 
For these reduction paths, Lemma~\ref{lem:compute context} gives a reduction $W\ALnotbeta \unfold(V)$.
%
The corresponding reduction path $T'\rewrite U'$ gives $\R(U')\leq\R(T')$, so that the induction hypothesis applies.



	\item
If the reduction step $T\rewrite^1U$ is a beta-step where $u=\lambda x.u'$ is the function, and the argument $v$ is the first element of the context $\cxt\overline{w\D}$, then $U$ and $U'$ are as follows.
\[
	U = (u'\sub xv)\overline{w'\D}
\qquad
	U'= (u'\sub xv)\overline{w'\D^*}
\]
Here, $\overline{w'\D}$ is $\overline{w\D}$ with the first application $v$ removed; it follows that $U^n=\tup*{\vv*x,\vv*y}\overline{w'\D}\in\SN$ because $T^n=(\tup*{\vv*x}v)\overline{w'\D}\in\SN$, where $\vv*x$ and $\vv*y$ are the free variables of $\lambda x.u'$ and $v$ respectively.
%
The induction hypothesis applies since $\R(U')<\R(T')$.


	\item
Let the reduction step $T\rewrite^1U$ be an application of rule \eqref{eqn:compound sharings}, combining two sharings $\g=\share*{\vv*y}y$ and $\g*=\share*{\vv*x,y,\vv*z}t$ into one $[\delta']=\share*{\vv*x,\vv*y,\vv*z}t$, where $u=u'\g$ and $\g*$ is the first element of the context $\overline{w\D}$.
%
Then $U$ and $U'$ are as follows.
\[
	U = u'[\delta']\overline{w\D}
\qquad
	U'= u'[\delta']^*\overline{w\D^*}
\]
Then $T'=u'\g\g*^*\overline{w\D^*}\rewrite U'$, and hence $\R(U')<\R(T')$.
%
The difference between $T^n$ and $U^n$ is that between the following $n$-terms.
\[
	\tup*{\vv*x,y,\vv*z}\share*{\vv*x,y,\vv*z}t
\qquad
	\tup*{\vv*x,\vv*y,\vv*z}\share*{\vv*x,\vv*y,\vv*z}t
\]
While $t$ may be duplicated more times in $U^n$ than in $T^n$, since no interaction is possible between the elements of a tuple it follows that $U^n\in\SN$, so that the induction hypothesis applies.



	\item
Finally, there is one case where $u=u'\g$ and a reduction step forces the closure $\g$ into the context $\overline{w\D}$.
%
Since the context $\overline{w\D}$ consists of closures and applications; moving $\g$ into it means it must be permuted past a closure $\g*$ or an application $(\cdot)v$.
%
In the former case, $u'\g\g*\sim u'\g*\g$ is an equivalence, not a rewrite step; thus the reduction step must be an application of rewrite rule \eqref{eqn:sharing above application function}.
%
But because of the congruence $\sim$ on terms, the application $(\cdot)v$ need not be the first element of $\overline{w\D}$: there may be closures $\G$ such that $u\g\G\sim u\G\g$.
%
Then consider the following rewrite step.
\[
	(u'\g\G)v\sim(u'\G\g)v\rewrite^1((u'\G)v)\g
\]
%
Then $T$, $T'$, $U$ and $U'$ are as follows.
%
\begin{align*}
	T &= ((u'\g\G)v)\overline{w'\D'}
&	T'&= ((u'\g\G^*)v)\overline{w'\D'^*}
\\[5pt]
	U &= ((u'\G)v)\g\overline{w'\D'}
&	U'&= ((u'\G^*)v)\g\overline{w'\D'^*}
\end{align*}
%
Here, the context $\cxt\overline{w\D}=((\cxt\G)v)\overline{w'\D'}$.
%
Since $T'\rewrite^1U'$ we have that $\R(T')<\R(U')$.
%
To apply the induction hypothesis to $U$ and $U'$, due to the presence of $\G^*$ we are forced to include $\g$ into the context $\overline{w\D}$.
%
It must then be shown that the $n$-term $U^n$ is in $\SN$, given that $T^n\in\SN$; however, $U^n$ includes $\g$ where $T^n$ does not:
%
\begin{align*}
	T^n &= ((\tup*{\vv x,\vv[m]y}\G)v)\overline{w'\D'}
\\[5pt]
	U^n &= ((\tup*{\vv x,\vv[k]z}\G)v)\g\overline{w'\D'}~.
\end{align*}
%
Here, $\FV(\term\g)=\{\vv[m]y\}$ and $\FV(u')=\{\vv x,\vv[k]z\}$, with the $z_i$ bound by $\g$.

\medskip

In case $\overline{w'\D'}$ does not bind in $\g$, it follows that $U^n\in\SN$ because $\term\g\in\SN$ (as it is a subterm of $T'\in\SN$) and $T^n\in\SN$.

\medskip

Otherwise, let $\overline{w'\D'}$ bind in $\g$.
%
The $n$-term $B'$ below is obtained from $T'$ by replacing $u=u'\g$ by the tuple $\tup*{\vv x,\term\g}$.
%
\[
	B' = ((\tup*{\vv x,\term\g}\G^*)v)\overline{w'\D'^*}\in\SN
\]
%
Recall that the $x_i$ are the free variables of $u'$ not bound by $\g$; then each element of the tuple is a subterm of $u$.
%
Then since $T'\in\SN$, also $B'\in\SN$, and since $\overline{w'\D'}$ binds in $\g$, the computations or closures in $\overline{w'\D'^*}$ binding in $\term\g$ create reductions in $u\g$ that have no counterpart in $\tup*{\vv x,\term\g}$, so that $\R(B')<\R(T')$.
%
Then the induction hypothesis can be applied for $B'$ and the term $B$ below, with $B^n=T^n\in\SN$, giving $B\in\SN$.
\[
	B = ((\tup*{\vv x,\term\g}\G)v)\overline{w'\D'}
\]
%
From this it follows that $U^n\in\SN$, by the following argument.
%
Let $B^1,\dots,B^m$ be variants of $B$. 
%
Then a reduction step in $U^n$ must do one of three things:
\begin{compactenum}[(a)]
	\item if it duplicates a part of $\term\g$ from $\g$ into a $y_i$, it is a sharing step, of which there are only finitely many until a step of kind (b) or (c) is performed,
	\item if it applies to an $x_i$ or outside the tuple, there is a corresponding step in each $B^j$,
	\item if it applies to a (part of) $\term\g^i$ that has been duplicated into the tuple, there is a corresponding step in $B^i$.
\end{compactenum}
%
\end{enumerate}
\end{proof}



% 
% =================================================================================================
\section{Conclusions and further work}



The present result, of strong normalisation for the simply typed atomic lambda-calculus, emphasises how the calculus is a natural and well-behaved formalisation of sharing in the lambda-calculus.
%
Future investigations will expand in three directions: strengthening the current strong normalisation result; adapting the atomic lambda-calculus to address further notions of sharing; and investigating the practical use of the calculus in computation, for instance in compiling or implementing functional programming languages.



The present work strongly suggests two angles for future research.
%
A natural extension would be to characterise the strongly normalisable atomic lambda-terms by an intersection typing discipline \cite{Coppo-DezaniCiancaglini-1980,Pottinger-1980,Krivine-1993}, to which the current reducibility proof is expected to extend naturally.
%
In a second direction, it is expected that the type system and strong normalisation proof can be extended to the second-order case---although subject reduction is not immediately obvious.


For the atomic lambda-calculus in general, further work will focus on variations on the calculus that more closely approach the reduction dynamics of sharing graphs, to encompass further degrees of sharing.
%
Another direction would be the inclusion of general recursion in the calculus, and the investigation of its interaction with the sharing constructs, as a prerequisite of making the calculus useful in practice to the implementation of functional programming languages.



\bibliographystyle{plain}
\bibliography{AL-LPAR}



\end{document}

